{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"nebula","usesPingPong":false,"speed":0.49,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision mediump int;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;uniform float uTime;out vec4 fragColor;const float TAU = 6.28318530718;\nconst float PI = 3.14159265359;const mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);const mat3 GOLD_PHI = mat3(\n-0.924648, -0.449886, 1.249265,\n1.318571, -0.490308, 0.800377,\n0.156297, 1.474868, 0.646816);const mat3 ROT1 = mat3(-0.57, 0.81, 0.10, -0.28, -0.30, 0.91, 0.77, 0.49, 0.40);\nconst mat3 ROT2 = mat3(0.1746, -0.6561, 0.7314, 0.9452, 0.3072, 0.0211, -0.2389, 0.6865, 0.6863);float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);vec3 lms1 = safeCbrt(kCONEtoLMS * lin1);\nvec3 lms2 = safeCbrt(kCONEtoLMS * lin2);\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.025 * a * (1.0 - a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 Tonemap_ACES(vec3 x) {\nconst float a = 2.51;\nconst float b = 0.03;\nconst float c = 2.43;\nconst float d = 0.59;\nconst float e = 0.14;\nreturn (x * (a * x + b)) / (x * (c * x + d) + e);\n}vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}float dot_noise(vec3 p) {\nreturn dot(cos(GOLD * p), sin(GOLD_PHI * p));\n}float sdCircle(vec2 uv, vec2 scale) {\nvec2 scaledUv = uv / scale;\nreturn length(scaledUv) - 1.0;\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float getDistance(vec2 uv, float scale) {\nvec2 finalScale = scale * vec2(1.0 - 0.0000 * 0.5, 1.0 + 0.0000 * 0.5);\nfinalScale *= mix(0.8, 1.2, 0.3300);\nreturn sdCircle(uv, finalScale);\n}float density(vec3 q, float amplitude) {\nfloat d = 0.0;\nfloat fd = 0.0;q.xy = (q.xy - 0.5) * vec2(1.0 - 0.0000 * 0.5, 1. + 0.0000 * 0.5) + 0.5;\nq.z = q.z * mix(1., 0.001, 0.3600);\nfloat n = dot_noise(q * vec3(1.6, 0.8, 1.1)) - 0.2;\nd += amplitude * n;\nfloat val = d * 0.5 + 0.5;\nfd += max(0.0, val) * amplitude;\nq = (ROT1 * (q * vec3(0.8, 1.6, 0.9))) * 2.2 + vec3(1.025, 0.575, 0.425);\namplitude *= 0.5 + 0.5 * (n * 0.5);\nn = dot_noise(q) - 0.2;\nd += amplitude * n;\nval = d * 0.5 + 0.5;\nfd += (val * val) * amplitude;\nq = (ROT2 * (q * vec3(1.6, 0.8, 1.1))) * 2.6 + vec3(2.05, 1.15, 0.85);\namplitude *= 0.5 + 0.5 * abs(n);\nn = dot_noise(q) + 0.2;\nd += amplitude * n;\nval = d * 0.5 + 0.5;\nfd += (val * val) * amplitude;\nreturn fd;\n}void main() {\nvec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nvec2 pos = vec2(0.6958333333333326, 0.5) + (uMousePos - 0.5) * 0.0000;\nfloat mDist = length(uv * aspect - vec2(0.6958333333333326, 0.5) * aspect + (uMousePos - 0.5) * aspect);\nmDist = smoothstep(0.0, 0.5, (0.05/mDist) * 2.0);\nvec2 sdfUv = (uv - vec2(0.6958333333333326, 0.5) - vec2(0, 0)) * aspect;\nfloat angleRad = 0.2500 * -TAU;\nsdfUv = rot(angleRad) * sdfUv;\nvec2 mouseOffset = rot(angleRad) * ((uMousePos - 0.5) * 0.0000 * aspect);\nsdfUv -= mouseOffset;\nfloat sdf = getDistance(sdfUv, 0.3900);\nfloat ampSdf = smoothstep(0.1, 0.3300 * 1.5, -sdf);vec3 col = vec3(0.0);\nfloat transmittance = 1.0;vec3 debug = vec3(0.0);\nfloat accumulatedLight = 0.0;\nif(ampSdf > 0.0) {\nvec2 uvCentered = (uv - vec2(0.6958333333333326, 0.5)) * aspect;\nvec3 ro = vec3(pos.x, pos.y, -3.0);\nvec3 rd = normalize(vec3(uvCentered, 1.0));const int STEPS = 40;\nfloat MAX_DIST = 1.0 + (0.3600 * 2.0);\nfloat baseStep = MAX_DIST / float(STEPS);\nfloat ign = interleavedGradientNoise(uResolution * vTextureCoord);\nfloat t = baseStep * (ign) * 0.999;\nfloat wrappedTime = (uTime) * 0.05 + 1.0000 * 50.0;vec3 colorCenter = oklab_mix(vec3(0.6823529411764706, 0, 0.12549019607843137), vec3(1, 1, 1), 0.5);\nvec3 colorDelta = oklab_mix(vec3(1, 1, 1), vec3(0.6823529411764706, 0, 0.12549019607843137), 0.5);\nfloat absorptionFactor = baseStep * mix(-2.0, -6.0, 0.9100);\nfloat scale = mix(2.0, 8.0, 0.8600);\nfloat lastDensity = 0.0;\nfloat ampBase = mix(0.2, 1.2, 0.2600) * 2.0;\nfloat amplitude = mix(ampBase, ampBase * ampSdf, 1.0000);\nvec3 q_ro = ro * scale + vec3(-vec3(0, 0, 1).x, vec3(0, 0, 1).y, vec3(0, 0, 1).z + (0.3600 * 2.0)) * wrappedTime;\nvec3 q_rd = rd * scale;\nfloat maxDepthFull = MAX_DIST;\nfloat maxDepthClipped = MAX_DIST * (0.2 + 0.8 * ampSdf * ampSdf);\nfloat maxDepth = mix(maxDepthFull, maxDepthClipped, 1.0000);\nint emptySteps = 0;\nfloat accumulatedLight = 0.0;\nbool hit = false;\nfloat densityThreshold = 0.0001;\nfloat saturationThreshold = 0.33;\nint maxEmptySteps = 20;\nfor(int i = 0; i < STEPS; i++) {\nif(transmittance < 0.01 || t > maxDepth) break;\nif(!hit && emptySteps > maxEmptySteps) break;\nif(accumulatedLight > saturationThreshold) break;\nfloat pz = ro.z + rd.z * t;\nif(lastDensity > 2.0 && pz < -2.0) break;\nvec3 q = q_ro + q_rd * t;\nfloat d = density(q, amplitude);\nfloat depthRatio = t / maxDepth;\nfloat zFadeFull = smoothstep(-3.0, -2.0, pz) * (1.0 - depthRatio * depthRatio);\nfloat zFadeClipped = smoothstep(-3.0, -2.0, pz) * (1.0 - depthRatio * depthRatio * (1.0 - ampSdf));\nfloat zFade = mix(zFadeFull, zFadeClipped, 1.0000);\nd *= zFade;\nlastDensity = d;\nif(d > densityThreshold) {\nfloat d_val = 0.25 / d;\nfloat atten = smoothstep(0.0, 1.0, d_val );\nfloat colorMix = atten;\nfloat chroma = 0.5;\nvec3 mixed = pal(colorMix,\ncolorCenter,\ncolorDelta,\nvec3(1. - chroma, 1.0, 1. + chroma),\nvec3(chroma, 0., -chroma)\n);\nvec3 light = mixed * atten;\nfloat absorption = exp(-d * baseStep * 20.0);\nvec3 contribution = light * d * transmittance * absorptionFactor;\ncol += contribution;\naccumulatedLight += abs(dot(contribution, vec3(0.299, 0.587, 0.114)));\ntransmittance *= absorption;\nemptySteps = 0;\nhit = true;\n} else {\nemptySteps++;\n}t += baseStep;debug = vec3(float(i)/float(STEPS));\n}\n}float maskStrength = mix(ampSdf, 1.0, 1.0000);\ncol *= maskStrength;\ncol = Tonemap_ACES(col);\nvec3 blended;\nfloat alpha = 1.;\ntransmittance = mix(1.0, transmittance, maskStrength);\ntransmittance = smoothstep(0.0, 1.0, transmittance);\nblended = col + bg.rgb * transmittance;\nalpha = max(bg.a, 1. - transmittance); - transmittance;\nvec3 finalCol = mix(bg.rgb, blended, 1.0000);\nvec4 color = vec4(finalCol, alpha);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"nebula"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float PI2 = 6.28318530718;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.2500 - 0.1, 0.2500, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI2 = 6.28318530718;float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec4 godRays(vec2 st) {\nvec3 color = vec3(0);\nfloat decay = mix(0.89, 0.965, 0.9300);\nvec2 pos = vec2(0.772, 0.5512) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000);\nfloat weight = 1.0;\nfloat MAX_ITERATIONS = 32.0;\nvec2 stepDir = (pos - st) / MAX_ITERATIONS * (0.25 + min(1., 0.9300)) * 0.75;\nfloat noise = interleavedGradientNoise(st * uResolution);\nvec2 sampleUv = st + stepDir * noise;\nvec2 perpDir = vec2(-stepDir.y, stepDir.x);\nfloat intensity = 2.8 * 0.6800;for (float i = 0.0; i < MAX_ITERATIONS; i++) {\nfloat theta = i/MAX_ITERATIONS;\nsampleUv += stepDir + (perpDir * theta * sin((noise * 0.25) * (1.0 + theta) * 50.0)) * 0.0000 * 0.25;\ncolor += texture(uTexture, sampleUv).rgb * weight * intensity;\nweight *= decay;\nif(weight < 0.05) break;\n}\nreturn vec4(color / MAX_ITERATIONS, 1.0);\n}vec4 getGodRays(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nif(0.6800 <= 0.01) {\nreturn bg;\n}\nvec4 rays = godRays(uv);\nrays.rgb *= vec3(1, 1, 1);vec4 color;\ncolor.rgb = bg.rgb + rays.rgb;\ncolor.a = bg.a + rays.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"includeBg":true}]},"id":"god_rays"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"voronoi","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t * t;\n}\nvec2 random2( vec2 p ) {\nreturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nout vec4 fragColor;vec2 voronoidNoise(vec2 st) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float m_dist = 15.;\nvec2 m_point;\nvec2 d;for (int j=-1; j<=1; j++ ) {\nfor (int i=-1; i<=1; i++ ) {\nvec2 neighbor = vec2(float(i),float(j));\nvec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point);\nvec2 diff = neighbor + point - f_st;\nfloat dist = length(diff);if( dist < m_dist ) {\nm_dist = dist;\nm_point = point;\nd = diff;\n}\n}\n}return m_point;\n}\nvec2 voronoiFBM(vec2 st) {\nvec2 value = vec2(0.0);\nvec2 shift = vec2(100.0);\nfloat xp = sqrt(2.);\nmat2 r = rot(0.5);\nfor (int i = 0; i < 3; i++) {\nvalue += voronoidNoise(st);\nst = st * xp + shift;\nst = r * st;\n}\nreturn value / float(3);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 1.0000);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.3500;\nst = st * rot(0.0000 * 2. * PI) * skew;\nvec2 m_point = voronoiFBM(st);vec2 offset = (m_point * 0.2 * 0.2100 * 2.) - (0.2100 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(0.8600));\nfloat dist = ease(1, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.8600)));vec4 color = texture(uTexture, uv + offset * dist);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"shatter"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));\nfloat amount = 0.0000 * ease(0, mix(inner, outer, 0.5000));\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount/144.;\ncolor += texture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000));\n}\nreturn color/float(kernelSize);\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn BoxBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));\nfloat amount = 0.0000 * ease(0, mix(inner, outer, 0.5000));\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount/144.;\ncolor += texture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000));\n}\nreturn color/float(kernelSize);\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn BoxBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));\nfloat amount = 0.0000 * ease(0, mix(inner, outer, 0.5000));\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount/144.;\ncolor += texture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000));\n}\nreturn color/float(kernelSize);\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn BoxBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));\nfloat amount = 0.0000 * ease(0, mix(inner, outer, 0.5000));\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount/144.;\ncolor += texture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000));\n}\nreturn color/float(kernelSize);\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn BoxBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"vertical","value":1,"downSample":0.25},{"prop":"vertical","value":2,"downSample":0.5},{"prop":"vertical","value":3,"downSample":0.5}]},"id":"blur"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;vec3 getFilteredColor(vec3 color) {\nreturn color;\n}float hueToRgb(float p, float q, float t) {\nif (t < 0.0) t += 1.0;\nif (t > 1.0) t -= 1.0;\nif (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\nif (t < 1.0 / 2.0) return q;\nif (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\nreturn p;\n}vec3 hslToRgb(vec3 hsl) {\nfloat h = hsl.x;\nfloat s = hsl.y;\nfloat l = hsl.z;\nvec3 rgb = vec3(l);\nif (s != 0.0) {\nfloat q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\nfloat p = 2.0 * l - q;\nrgb.r = hueToRgb(p, q, h + 1.0 / 3.0);\nrgb.g = hueToRgb(p, q, h);\nrgb.b = hueToRgb(p, q, h - 1.0 / 3.0);\n}\nreturn rgb;\n}vec3 rgbToHsl(vec3 rgb) {\nfloat max = max(max(rgb.r, rgb.g), rgb.b);\nfloat min = min(min(rgb.r, rgb.g), rgb.b);\nfloat h, s, l = (max + min) / 2.0;if (max == min) {\nh = s = 0.0;\n} else {\nfloat d = max - min;\ns = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\nif (max == rgb.r) {\nh = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0);\n} else if (max == rgb.g) {\nh = (rgb.b - rgb.r) / d + 2.0;\n} else if (max == rgb.b) {\nh = (rgb.r - rgb.g) / d + 4.0;\n}\nh /= 6.0;\n}return vec3(h, s, l);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = rgbToHsl(color.rgb);\ncolor.x = fract(color.x + 1.0000);\ncolor.y = clamp(color.y * 2.0000, 0.0, 1.0);\ncolor.z = clamp(color.z + 0.0000, 0.0, 1.0);\ncolor.rgb = hslToRgb(color.rgb);\ncolor.rgb = getFilteredColor(color.rgb);color.rgb = 1.1600 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + 0.0000, 0.0, 1.0);\ncolor.b = clamp(color.b - 0.0000, 0.0, 1.0);color.g = clamp(color.g - 0.0000, 0.0, 1.0);\ncolor.r = clamp(color.r + 0.0000 * 0.5, 0.0, 1.0);\ncolor.b = clamp(color.b + 0.0000 * 0.5, 0.0, 1.0);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"adjust"}],"options":{"name":"Shattered Nebula Orb (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"2.0.4","id":"syZV2CVUpIFF94ddKUym"}